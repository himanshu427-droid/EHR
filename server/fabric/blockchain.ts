import { Gateway, Wallets, Wallet, GatewayOptions, Contract } from 'fabric-network';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto'; // Added for hashing
import { fileURLToPath } from 'url';

// --- Configuration ---
// These paths are relative to this file (server/fabric/blockchain.ts)

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Path to the file system wallet that holds the identities (Admin, appUser).
 * This assumes a 'wallet' directory at the 'server' level.
 * (e.g., /EHR/server/wallet)
 */
const WALLET_PATH = path.resolve(__dirname, '..', 'wallet');

/**
 * Path to the connection profile for Org1.
 * This file is generated by the test-network.
 * (e.g., /EHR/fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/connection-org1.json)
 */
const CCP_PATH = path.resolve(
  __dirname, // server/fabric
  '..', // server
  '..', // EHR (root)
  'fabric-samples',
  'test-network',
  'organizations',
  'peerOrganizations',
  'org1.example.com',
  'connection-org1.json'
);

// --- Fabric Constants ---
const CHANNEL_NAME = 'ehrchannel';
const CHAINCODE_NAME = 'ehr';

/**
 * The identity name to use for connecting to the network.
 * This identity must be enrolled and exist in your WALLET_PATH.
 * You typically create this using the 'registerUser.js' script.
 */
const IDENTITY_NAME = 'appUser';

// --- Internal Function ---

/**
 * Connects to the Fabric gateway and returns the contract and gateway objects.
 * This function is used by both submit and evaluate.
 */
async function connectToGateway(): Promise<{ contract: Contract; gateway: Gateway }> {
  // 1. Load the wallet
  const wallet: Wallet = await Wallets.newFileSystemWallet(WALLET_PATH);
  console.log(`Wallet path: ${WALLET_PATH}`);

  // 2. Check if the identity exists
  const identity = await wallet.get(IDENTITY_NAME);
  if (!identity) {
    console.error(`Identity '${IDENTITY_NAME}' not found in wallet.`);
    console.error('Please run the registerUser.js script before starting the server.');
    throw new Error(`Identity '${IDENTITY_NAME}' not found.`);
  }

  // 3. Load the connection profile (CCP)
  const ccpRaw = fs.readFileSync(CCP_PATH, 'utf8');
  const ccp = JSON.parse(ccpRaw);

  // 4. Set up gateway connection options
  const gatewayOptions: GatewayOptions = {
    wallet,
    identity: IDENTITY_NAME,
    discovery: { enabled: true, asLocalhost: true }, // Use discovery service
  };

  // 5. Connect to the gateway
  const gateway = new Gateway();
  try {
    await gateway.connect(ccp, gatewayOptions);
    console.log('Connected to Fabric gateway.');

    // 6. Get the network (channel)
    const network = await gateway.getNetwork(CHANNEL_NAME);

    // 7. Get the contract (chaincode)
    const contract = network.getContract(CHAINCODE_NAME);
    console.log(`Using chaincode '${CHAINCODE_NAME}' on channel '${CHANNEL_NAME}'.`);

    return { contract, gateway };
  } catch (error) {
    // Disconnect on connection failure
    gateway.disconnect();
    console.error('Failed to connect to gateway:', error);
    throw error;
  }
}

// --- Core Transaction Functions (Internal) ---

/**
 * Submits a transaction to the ledger (for Create, Update, Delete operations).
 * @param functionName - The chaincode function to call (e.g., 'createEHR').
 * @param args - The arguments to pass to the chaincode function.
 * @returns The result from the chaincode, typically a stringified object.
 */
async function submitTransaction(functionName: string, ...args: string[]): Promise<string> {
  let gateway: Gateway | undefined;
  try {
    // Connect and get the contract
    const connectResult = await connectToGateway();
    gateway = connectResult.gateway; // Get the gateway to disconnect in finally
    const contract = connectResult.contract;

    // Submit the transaction
    console.log(`--> Submitting Transaction: ${functionName} with args: ${args.join(', ')}`);
    const resultBuffer = await contract.submitTransaction(functionName, ...args);

    // Process and return the result
    const result = resultBuffer.toString();
    console.log('--> Transaction submitted successfully. Result:', result);
    return result;
  } catch (error) {
    console.error(`Failed to submit transaction: ${error}`);
    throw error; // Re-throw for your API controller to catch
  } finally {
    // Always disconnect the gateway
    if (gateway) {
      gateway.disconnect();
      console.log('Gateway disconnected.');
    }
  }
}

/**
 * Evaluates a query on the ledger (for Read operations).
 * @param functionName - The chaincode function to call (e.g., 'readEHR').
 * @param args - The arguments to pass to the chaincode function.
 * @returns The result from the chaincode, typically a stringified JSON object.
 */
async function evaluateTransaction(functionName: string, ...args: string[]): Promise<string> {
  let gateway: Gateway | undefined;
  try {
    // Connect and get the contract
    const connectResult = await connectToGateway();
    gateway = connectResult.gateway; // Get the gateway to disconnect in finally
    const contract = connectResult.contract;

    // Evaluate the transaction (read-only query)
    console.log(`--> Evaluating Query: ${functionName} with args: ${args.join(', ')}`);
    const resultBuffer = await contract.evaluateTransaction(functionName, ...args);

    // Process and return the result
    const result = resultBuffer.toString();
    console.log(`--> Query successful. Result: ${result}`);
    return result;
  } catch (error) {
    console.error(`Failed to evaluate transaction: ${error}`);
    throw error; // Re-throw for your API controller to catch
  } finally {
    // Always disconnect the gateway
    if (gateway) {
      gateway.disconnect();
      console.log('Gateway disconnected.');
    }
  }
}

// --- Utility and Wrapper Functions (Internal) ---
// These are the functions your routes.ts file expects.

/**
 * Creates a SHA-256 hash of any data.
 */
function hashData(data: any): string {
  const dataString = typeof data === 'string' ? data : JSON.stringify(data);
  return crypto.createHash('sha256').update(dataString).digest('hex');
}

/**
 * Wrapper for the 'addRecord' chaincode function.
 * Chaincode expects: (recordId, patientId, recordHash, doctorId, metadata)
 */
async function addRecord(patientId: string, dataHash: string, doctorId: string | null): Promise<string> {
  const doctorIdStr = doctorId || ''; // Pass empty string if null/undefined
  const recordId = crypto.randomUUID(); // generate a unique record id for ledger key
  const metadataStr = JSON.stringify({ createdBy: doctorIdStr || 'system', createdAt: new Date().toISOString() });
  return submitTransaction('addRecord', recordId, patientId, dataHash, doctorIdStr, metadataStr);
}

/**
 * Wrapper for the 'grantAccess' chaincode function.
 * Chaincode expects: (accessId, patientId, entityId, permissions)
 */
async function grantAccess(patientId: string, entityId: string, permissions: string[]): Promise<string> {
  const permissionsStr = JSON.stringify(permissions);
  const accessId = crypto.randomUUID();
  return submitTransaction('grantAccess', accessId, patientId, entityId, permissionsStr);
}

/**
 * Wrapper for the 'revokeAccess' chaincode function.
 * Chaincode expects: (accessId)
 * We'll accept (patientId, entityId) in caller code but here we require accessId.
 */
async function revokeAccess(accessId: string): Promise<string> {
  return submitTransaction('revokeAccess', accessId);
}

// --- Exported Service Object ---
// This is what your routes.ts file will import.

export const blockchainService = {
  submitTransaction,
  evaluateTransaction,
  hashData,
  addRecord,
  grantAccess,
  revokeAccess,
};